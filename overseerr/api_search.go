/*
Overseerr API

This is the documentation for the Overseerr API backend.  Two primary authentication methods are supported:  - **Cookie Authentication**: A valid sign-in to the `/auth/plex` or `/auth/local` will generate a valid authentication cookie. - **API Key Authentication**: Sign-in is also possible by passing an `X-Api-Key` header along with a valid API Key generated by Overseerr. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package overseerr

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SearchAPIService SearchAPI service
type SearchAPIService service
type ApiGetDiscoverKeywordMoviesRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	keywordId float32
	page *float32
	language *string
}

func (r ApiGetDiscoverKeywordMoviesRequest) Page(page float32) ApiGetDiscoverKeywordMoviesRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverKeywordMoviesRequest) Language(language string) ApiGetDiscoverKeywordMoviesRequest {
	r.language = &language
	return r
}

func (r ApiGetDiscoverKeywordMoviesRequest) Execute() (*GetDiscoverMovies2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverKeywordMoviesExecute(r)
}

/*
GetDiscoverKeywordMovies Get movies from keyword

Returns list of movies based on the provided keyword ID a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param keywordId
 @return ApiGetDiscoverKeywordMoviesRequest
*/
func (a *SearchAPIService) GetDiscoverKeywordMovies(ctx context.Context, keywordId float32) ApiGetDiscoverKeywordMoviesRequest {
	return ApiGetDiscoverKeywordMoviesRequest{
		ApiService: a,
		ctx: ctx,
		keywordId: keywordId,
	}
}

// Execute executes the request
//  @return GetDiscoverMovies2XXResponse
func (a *SearchAPIService) GetDiscoverKeywordMoviesExecute(r ApiGetDiscoverKeywordMoviesRequest) (*GetDiscoverMovies2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDiscoverMovies2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverKeywordMovies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/keyword/{keywordId}/movies"
	localVarPath = strings.Replace(localVarPath, "{"+"keywordId"+"}", url.PathEscape(parameterToString(r.keywordId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverMoviesRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	page *float32
	language *string
	genre *string
	studio *float32
	keywords *string
	sortBy *string
	primaryReleaseDateGte *string
	primaryReleaseDateLte *string
	withRuntimeGte *float32
	withRuntimeLte *float32
	voteAverageGte *float32
	voteAverageLte *float32
	voteCountGte *float32
	voteCountLte *float32
	watchRegion *string
	watchProviders *string
}

func (r ApiGetDiscoverMoviesRequest) Page(page float32) ApiGetDiscoverMoviesRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverMoviesRequest) Language(language string) ApiGetDiscoverMoviesRequest {
	r.language = &language
	return r
}

func (r ApiGetDiscoverMoviesRequest) Genre(genre string) ApiGetDiscoverMoviesRequest {
	r.genre = &genre
	return r
}

func (r ApiGetDiscoverMoviesRequest) Studio(studio float32) ApiGetDiscoverMoviesRequest {
	r.studio = &studio
	return r
}

func (r ApiGetDiscoverMoviesRequest) Keywords(keywords string) ApiGetDiscoverMoviesRequest {
	r.keywords = &keywords
	return r
}

func (r ApiGetDiscoverMoviesRequest) SortBy(sortBy string) ApiGetDiscoverMoviesRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetDiscoverMoviesRequest) PrimaryReleaseDateGte(primaryReleaseDateGte string) ApiGetDiscoverMoviesRequest {
	r.primaryReleaseDateGte = &primaryReleaseDateGte
	return r
}

func (r ApiGetDiscoverMoviesRequest) PrimaryReleaseDateLte(primaryReleaseDateLte string) ApiGetDiscoverMoviesRequest {
	r.primaryReleaseDateLte = &primaryReleaseDateLte
	return r
}

func (r ApiGetDiscoverMoviesRequest) WithRuntimeGte(withRuntimeGte float32) ApiGetDiscoverMoviesRequest {
	r.withRuntimeGte = &withRuntimeGte
	return r
}

func (r ApiGetDiscoverMoviesRequest) WithRuntimeLte(withRuntimeLte float32) ApiGetDiscoverMoviesRequest {
	r.withRuntimeLte = &withRuntimeLte
	return r
}

func (r ApiGetDiscoverMoviesRequest) VoteAverageGte(voteAverageGte float32) ApiGetDiscoverMoviesRequest {
	r.voteAverageGte = &voteAverageGte
	return r
}

func (r ApiGetDiscoverMoviesRequest) VoteAverageLte(voteAverageLte float32) ApiGetDiscoverMoviesRequest {
	r.voteAverageLte = &voteAverageLte
	return r
}

func (r ApiGetDiscoverMoviesRequest) VoteCountGte(voteCountGte float32) ApiGetDiscoverMoviesRequest {
	r.voteCountGte = &voteCountGte
	return r
}

func (r ApiGetDiscoverMoviesRequest) VoteCountLte(voteCountLte float32) ApiGetDiscoverMoviesRequest {
	r.voteCountLte = &voteCountLte
	return r
}

func (r ApiGetDiscoverMoviesRequest) WatchRegion(watchRegion string) ApiGetDiscoverMoviesRequest {
	r.watchRegion = &watchRegion
	return r
}

func (r ApiGetDiscoverMoviesRequest) WatchProviders(watchProviders string) ApiGetDiscoverMoviesRequest {
	r.watchProviders = &watchProviders
	return r
}

func (r ApiGetDiscoverMoviesRequest) Execute() (*GetDiscoverMovies2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverMoviesExecute(r)
}

/*
GetDiscoverMovies Discover movies

Returns a list of movies in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDiscoverMoviesRequest
*/
func (a *SearchAPIService) GetDiscoverMovies(ctx context.Context) ApiGetDiscoverMoviesRequest {
	return ApiGetDiscoverMoviesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDiscoverMovies2XXResponse
func (a *SearchAPIService) GetDiscoverMoviesExecute(r ApiGetDiscoverMoviesRequest) (*GetDiscoverMovies2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDiscoverMovies2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverMovies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/movies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	if r.genre != nil {
		localVarQueryParams.Add("genre", parameterToString(*r.genre, ""))
	}
	if r.studio != nil {
		localVarQueryParams.Add("studio", parameterToString(*r.studio, ""))
	}
	if r.keywords != nil {
		localVarQueryParams.Add("keywords", parameterToString(*r.keywords, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.primaryReleaseDateGte != nil {
		localVarQueryParams.Add("primaryReleaseDateGte", parameterToString(*r.primaryReleaseDateGte, ""))
	}
	if r.primaryReleaseDateLte != nil {
		localVarQueryParams.Add("primaryReleaseDateLte", parameterToString(*r.primaryReleaseDateLte, ""))
	}
	if r.withRuntimeGte != nil {
		localVarQueryParams.Add("withRuntimeGte", parameterToString(*r.withRuntimeGte, ""))
	}
	if r.withRuntimeLte != nil {
		localVarQueryParams.Add("withRuntimeLte", parameterToString(*r.withRuntimeLte, ""))
	}
	if r.voteAverageGte != nil {
		localVarQueryParams.Add("voteAverageGte", parameterToString(*r.voteAverageGte, ""))
	}
	if r.voteAverageLte != nil {
		localVarQueryParams.Add("voteAverageLte", parameterToString(*r.voteAverageLte, ""))
	}
	if r.voteCountGte != nil {
		localVarQueryParams.Add("voteCountGte", parameterToString(*r.voteCountGte, ""))
	}
	if r.voteCountLte != nil {
		localVarQueryParams.Add("voteCountLte", parameterToString(*r.voteCountLte, ""))
	}
	if r.watchRegion != nil {
		localVarQueryParams.Add("watchRegion", parameterToString(*r.watchRegion, ""))
	}
	if r.watchProviders != nil {
		localVarQueryParams.Add("watchProviders", parameterToString(*r.watchProviders, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverMoviesGenreByGenreIdRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	genreId string
	page *float32
	language *string
}

func (r ApiGetDiscoverMoviesGenreByGenreIdRequest) Page(page float32) ApiGetDiscoverMoviesGenreByGenreIdRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverMoviesGenreByGenreIdRequest) Language(language string) ApiGetDiscoverMoviesGenreByGenreIdRequest {
	r.language = &language
	return r
}

func (r ApiGetDiscoverMoviesGenreByGenreIdRequest) Execute() (*GetDiscoverMoviesGenreByGenreId2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverMoviesGenreByGenreIdExecute(r)
}

/*
GetDiscoverMoviesGenreByGenreId Discover movies by genre

Returns a list of movies based on the provided genre ID in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param genreId
 @return ApiGetDiscoverMoviesGenreByGenreIdRequest
*/
func (a *SearchAPIService) GetDiscoverMoviesGenreByGenreId(ctx context.Context, genreId string) ApiGetDiscoverMoviesGenreByGenreIdRequest {
	return ApiGetDiscoverMoviesGenreByGenreIdRequest{
		ApiService: a,
		ctx: ctx,
		genreId: genreId,
	}
}

// Execute executes the request
//  @return GetDiscoverMoviesGenreByGenreId2XXResponse
func (a *SearchAPIService) GetDiscoverMoviesGenreByGenreIdExecute(r ApiGetDiscoverMoviesGenreByGenreIdRequest) (*GetDiscoverMoviesGenreByGenreId2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDiscoverMoviesGenreByGenreId2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverMoviesGenreByGenreId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/movies/genre/{genreId}"
	localVarPath = strings.Replace(localVarPath, "{"+"genreId"+"}", url.PathEscape(parameterToString(r.genreId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverMoviesLanguageByLanguageRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	language string
	page *float32
	language2 *string
}

func (r ApiGetDiscoverMoviesLanguageByLanguageRequest) Page(page float32) ApiGetDiscoverMoviesLanguageByLanguageRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverMoviesLanguageByLanguageRequest) Language2(language2 string) ApiGetDiscoverMoviesLanguageByLanguageRequest {
	r.language2 = &language2
	return r
}

func (r ApiGetDiscoverMoviesLanguageByLanguageRequest) Execute() (*GetDiscoverMoviesLanguageByLanguage2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverMoviesLanguageByLanguageExecute(r)
}

/*
GetDiscoverMoviesLanguageByLanguage Discover movies by original language

Returns a list of movies based on the provided ISO 639-1 language code in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param language
 @return ApiGetDiscoverMoviesLanguageByLanguageRequest
*/
func (a *SearchAPIService) GetDiscoverMoviesLanguageByLanguage(ctx context.Context, language string) ApiGetDiscoverMoviesLanguageByLanguageRequest {
	return ApiGetDiscoverMoviesLanguageByLanguageRequest{
		ApiService: a,
		ctx: ctx,
		language: language,
	}
}

// Execute executes the request
//  @return GetDiscoverMoviesLanguageByLanguage2XXResponse
func (a *SearchAPIService) GetDiscoverMoviesLanguageByLanguageExecute(r ApiGetDiscoverMoviesLanguageByLanguageRequest) (*GetDiscoverMoviesLanguageByLanguage2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDiscoverMoviesLanguageByLanguage2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverMoviesLanguageByLanguage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/movies/language/{language}"
	localVarPath = strings.Replace(localVarPath, "{"+"language"+"}", url.PathEscape(parameterToString(r.language, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language2 != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverMoviesStudioByStudioIdRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	studioId string
	page *float32
	language *string
}

func (r ApiGetDiscoverMoviesStudioByStudioIdRequest) Page(page float32) ApiGetDiscoverMoviesStudioByStudioIdRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverMoviesStudioByStudioIdRequest) Language(language string) ApiGetDiscoverMoviesStudioByStudioIdRequest {
	r.language = &language
	return r
}

func (r ApiGetDiscoverMoviesStudioByStudioIdRequest) Execute() (*GetDiscoverMoviesStudioByStudioId2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverMoviesStudioByStudioIdExecute(r)
}

/*
GetDiscoverMoviesStudioByStudioId Discover movies by studio

Returns a list of movies based on the provided studio ID in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param studioId
 @return ApiGetDiscoverMoviesStudioByStudioIdRequest
*/
func (a *SearchAPIService) GetDiscoverMoviesStudioByStudioId(ctx context.Context, studioId string) ApiGetDiscoverMoviesStudioByStudioIdRequest {
	return ApiGetDiscoverMoviesStudioByStudioIdRequest{
		ApiService: a,
		ctx: ctx,
		studioId: studioId,
	}
}

// Execute executes the request
//  @return GetDiscoverMoviesStudioByStudioId2XXResponse
func (a *SearchAPIService) GetDiscoverMoviesStudioByStudioIdExecute(r ApiGetDiscoverMoviesStudioByStudioIdRequest) (*GetDiscoverMoviesStudioByStudioId2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDiscoverMoviesStudioByStudioId2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverMoviesStudioByStudioId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/movies/studio/{studioId}"
	localVarPath = strings.Replace(localVarPath, "{"+"studioId"+"}", url.PathEscape(parameterToString(r.studioId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverMoviesUpcomingRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	page *float32
	language *string
}

func (r ApiGetDiscoverMoviesUpcomingRequest) Page(page float32) ApiGetDiscoverMoviesUpcomingRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverMoviesUpcomingRequest) Language(language string) ApiGetDiscoverMoviesUpcomingRequest {
	r.language = &language
	return r
}

func (r ApiGetDiscoverMoviesUpcomingRequest) Execute() (*GetDiscoverMovies2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverMoviesUpcomingExecute(r)
}

/*
GetDiscoverMoviesUpcoming Upcoming movies

Returns a list of movies in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDiscoverMoviesUpcomingRequest
*/
func (a *SearchAPIService) GetDiscoverMoviesUpcoming(ctx context.Context) ApiGetDiscoverMoviesUpcomingRequest {
	return ApiGetDiscoverMoviesUpcomingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDiscoverMovies2XXResponse
func (a *SearchAPIService) GetDiscoverMoviesUpcomingExecute(r ApiGetDiscoverMoviesUpcomingRequest) (*GetDiscoverMovies2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDiscoverMovies2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverMoviesUpcoming")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/movies/upcoming"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverTrendingRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	page *float32
	language *string
}

func (r ApiGetDiscoverTrendingRequest) Page(page float32) ApiGetDiscoverTrendingRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverTrendingRequest) Language(language string) ApiGetDiscoverTrendingRequest {
	r.language = &language
	return r
}

func (r ApiGetDiscoverTrendingRequest) Execute() (*GetSearch2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverTrendingExecute(r)
}

/*
GetDiscoverTrending Trending movies and TV

Returns a list of movies and TV shows in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDiscoverTrendingRequest
*/
func (a *SearchAPIService) GetDiscoverTrending(ctx context.Context) ApiGetDiscoverTrendingRequest {
	return ApiGetDiscoverTrendingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSearch2XXResponse
func (a *SearchAPIService) GetDiscoverTrendingExecute(r ApiGetDiscoverTrendingRequest) (*GetSearch2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSearch2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverTrending")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/trending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverTvRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	page *float32
	language *string
	genre *string
	network *float32
	keywords *string
	sortBy *string
	firstAirDateGte *string
	firstAirDateLte *string
	withRuntimeGte *float32
	withRuntimeLte *float32
	voteAverageGte *float32
	voteAverageLte *float32
	voteCountGte *float32
	voteCountLte *float32
	watchRegion *string
	watchProviders *string
}

func (r ApiGetDiscoverTvRequest) Page(page float32) ApiGetDiscoverTvRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverTvRequest) Language(language string) ApiGetDiscoverTvRequest {
	r.language = &language
	return r
}

func (r ApiGetDiscoverTvRequest) Genre(genre string) ApiGetDiscoverTvRequest {
	r.genre = &genre
	return r
}

func (r ApiGetDiscoverTvRequest) Network(network float32) ApiGetDiscoverTvRequest {
	r.network = &network
	return r
}

func (r ApiGetDiscoverTvRequest) Keywords(keywords string) ApiGetDiscoverTvRequest {
	r.keywords = &keywords
	return r
}

func (r ApiGetDiscoverTvRequest) SortBy(sortBy string) ApiGetDiscoverTvRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiGetDiscoverTvRequest) FirstAirDateGte(firstAirDateGte string) ApiGetDiscoverTvRequest {
	r.firstAirDateGte = &firstAirDateGte
	return r
}

func (r ApiGetDiscoverTvRequest) FirstAirDateLte(firstAirDateLte string) ApiGetDiscoverTvRequest {
	r.firstAirDateLte = &firstAirDateLte
	return r
}

func (r ApiGetDiscoverTvRequest) WithRuntimeGte(withRuntimeGte float32) ApiGetDiscoverTvRequest {
	r.withRuntimeGte = &withRuntimeGte
	return r
}

func (r ApiGetDiscoverTvRequest) WithRuntimeLte(withRuntimeLte float32) ApiGetDiscoverTvRequest {
	r.withRuntimeLte = &withRuntimeLte
	return r
}

func (r ApiGetDiscoverTvRequest) VoteAverageGte(voteAverageGte float32) ApiGetDiscoverTvRequest {
	r.voteAverageGte = &voteAverageGte
	return r
}

func (r ApiGetDiscoverTvRequest) VoteAverageLte(voteAverageLte float32) ApiGetDiscoverTvRequest {
	r.voteAverageLte = &voteAverageLte
	return r
}

func (r ApiGetDiscoverTvRequest) VoteCountGte(voteCountGte float32) ApiGetDiscoverTvRequest {
	r.voteCountGte = &voteCountGte
	return r
}

func (r ApiGetDiscoverTvRequest) VoteCountLte(voteCountLte float32) ApiGetDiscoverTvRequest {
	r.voteCountLte = &voteCountLte
	return r
}

func (r ApiGetDiscoverTvRequest) WatchRegion(watchRegion string) ApiGetDiscoverTvRequest {
	r.watchRegion = &watchRegion
	return r
}

func (r ApiGetDiscoverTvRequest) WatchProviders(watchProviders string) ApiGetDiscoverTvRequest {
	r.watchProviders = &watchProviders
	return r
}

func (r ApiGetDiscoverTvRequest) Execute() (*GetDiscoverTv2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverTvExecute(r)
}

/*
GetDiscoverTv Discover TV shows

Returns a list of TV shows in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDiscoverTvRequest
*/
func (a *SearchAPIService) GetDiscoverTv(ctx context.Context) ApiGetDiscoverTvRequest {
	return ApiGetDiscoverTvRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDiscoverTv2XXResponse
func (a *SearchAPIService) GetDiscoverTvExecute(r ApiGetDiscoverTvRequest) (*GetDiscoverTv2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDiscoverTv2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverTv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/tv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	if r.genre != nil {
		localVarQueryParams.Add("genre", parameterToString(*r.genre, ""))
	}
	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	if r.keywords != nil {
		localVarQueryParams.Add("keywords", parameterToString(*r.keywords, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.firstAirDateGte != nil {
		localVarQueryParams.Add("firstAirDateGte", parameterToString(*r.firstAirDateGte, ""))
	}
	if r.firstAirDateLte != nil {
		localVarQueryParams.Add("firstAirDateLte", parameterToString(*r.firstAirDateLte, ""))
	}
	if r.withRuntimeGte != nil {
		localVarQueryParams.Add("withRuntimeGte", parameterToString(*r.withRuntimeGte, ""))
	}
	if r.withRuntimeLte != nil {
		localVarQueryParams.Add("withRuntimeLte", parameterToString(*r.withRuntimeLte, ""))
	}
	if r.voteAverageGte != nil {
		localVarQueryParams.Add("voteAverageGte", parameterToString(*r.voteAverageGte, ""))
	}
	if r.voteAverageLte != nil {
		localVarQueryParams.Add("voteAverageLte", parameterToString(*r.voteAverageLte, ""))
	}
	if r.voteCountGte != nil {
		localVarQueryParams.Add("voteCountGte", parameterToString(*r.voteCountGte, ""))
	}
	if r.voteCountLte != nil {
		localVarQueryParams.Add("voteCountLte", parameterToString(*r.voteCountLte, ""))
	}
	if r.watchRegion != nil {
		localVarQueryParams.Add("watchRegion", parameterToString(*r.watchRegion, ""))
	}
	if r.watchProviders != nil {
		localVarQueryParams.Add("watchProviders", parameterToString(*r.watchProviders, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverTvGenreByGenreIdRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	genreId string
	page *float32
	language *string
}

func (r ApiGetDiscoverTvGenreByGenreIdRequest) Page(page float32) ApiGetDiscoverTvGenreByGenreIdRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverTvGenreByGenreIdRequest) Language(language string) ApiGetDiscoverTvGenreByGenreIdRequest {
	r.language = &language
	return r
}

func (r ApiGetDiscoverTvGenreByGenreIdRequest) Execute() (*GetDiscoverTvGenreByGenreId2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverTvGenreByGenreIdExecute(r)
}

/*
GetDiscoverTvGenreByGenreId Discover TV shows by genre

Returns a list of TV shows based on the provided genre ID in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param genreId
 @return ApiGetDiscoverTvGenreByGenreIdRequest
*/
func (a *SearchAPIService) GetDiscoverTvGenreByGenreId(ctx context.Context, genreId string) ApiGetDiscoverTvGenreByGenreIdRequest {
	return ApiGetDiscoverTvGenreByGenreIdRequest{
		ApiService: a,
		ctx: ctx,
		genreId: genreId,
	}
}

// Execute executes the request
//  @return GetDiscoverTvGenreByGenreId2XXResponse
func (a *SearchAPIService) GetDiscoverTvGenreByGenreIdExecute(r ApiGetDiscoverTvGenreByGenreIdRequest) (*GetDiscoverTvGenreByGenreId2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDiscoverTvGenreByGenreId2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverTvGenreByGenreId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/tv/genre/{genreId}"
	localVarPath = strings.Replace(localVarPath, "{"+"genreId"+"}", url.PathEscape(parameterToString(r.genreId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverTvLanguageByLanguageRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	language string
	page *float32
	language2 *string
}

func (r ApiGetDiscoverTvLanguageByLanguageRequest) Page(page float32) ApiGetDiscoverTvLanguageByLanguageRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverTvLanguageByLanguageRequest) Language2(language2 string) ApiGetDiscoverTvLanguageByLanguageRequest {
	r.language2 = &language2
	return r
}

func (r ApiGetDiscoverTvLanguageByLanguageRequest) Execute() (*GetDiscoverTvLanguageByLanguage2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverTvLanguageByLanguageExecute(r)
}

/*
GetDiscoverTvLanguageByLanguage Discover TV shows by original language

Returns a list of TV shows based on the provided ISO 639-1 language code in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param language
 @return ApiGetDiscoverTvLanguageByLanguageRequest
*/
func (a *SearchAPIService) GetDiscoverTvLanguageByLanguage(ctx context.Context, language string) ApiGetDiscoverTvLanguageByLanguageRequest {
	return ApiGetDiscoverTvLanguageByLanguageRequest{
		ApiService: a,
		ctx: ctx,
		language: language,
	}
}

// Execute executes the request
//  @return GetDiscoverTvLanguageByLanguage2XXResponse
func (a *SearchAPIService) GetDiscoverTvLanguageByLanguageExecute(r ApiGetDiscoverTvLanguageByLanguageRequest) (*GetDiscoverTvLanguageByLanguage2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDiscoverTvLanguageByLanguage2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverTvLanguageByLanguage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/tv/language/{language}"
	localVarPath = strings.Replace(localVarPath, "{"+"language"+"}", url.PathEscape(parameterToString(r.language, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language2 != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language2, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverTvNetworkByNetworkIdRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	networkId string
	page *float32
	language *string
}

func (r ApiGetDiscoverTvNetworkByNetworkIdRequest) Page(page float32) ApiGetDiscoverTvNetworkByNetworkIdRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverTvNetworkByNetworkIdRequest) Language(language string) ApiGetDiscoverTvNetworkByNetworkIdRequest {
	r.language = &language
	return r
}

func (r ApiGetDiscoverTvNetworkByNetworkIdRequest) Execute() (*GetDiscoverTvNetworkByNetworkId2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverTvNetworkByNetworkIdExecute(r)
}

/*
GetDiscoverTvNetworkByNetworkId Discover TV shows by network

Returns a list of TV shows based on the provided network ID in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId
 @return ApiGetDiscoverTvNetworkByNetworkIdRequest
*/
func (a *SearchAPIService) GetDiscoverTvNetworkByNetworkId(ctx context.Context, networkId string) ApiGetDiscoverTvNetworkByNetworkIdRequest {
	return ApiGetDiscoverTvNetworkByNetworkIdRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return GetDiscoverTvNetworkByNetworkId2XXResponse
func (a *SearchAPIService) GetDiscoverTvNetworkByNetworkIdExecute(r ApiGetDiscoverTvNetworkByNetworkIdRequest) (*GetDiscoverTvNetworkByNetworkId2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDiscoverTvNetworkByNetworkId2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverTvNetworkByNetworkId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/tv/network/{networkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterToString(r.networkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverTvUpcomingRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	page *float32
	language *string
}

func (r ApiGetDiscoverTvUpcomingRequest) Page(page float32) ApiGetDiscoverTvUpcomingRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverTvUpcomingRequest) Language(language string) ApiGetDiscoverTvUpcomingRequest {
	r.language = &language
	return r
}

func (r ApiGetDiscoverTvUpcomingRequest) Execute() (*GetDiscoverTv2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverTvUpcomingExecute(r)
}

/*
GetDiscoverTvUpcoming Discover Upcoming TV shows

Returns a list of upcoming TV shows in a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDiscoverTvUpcomingRequest
*/
func (a *SearchAPIService) GetDiscoverTvUpcoming(ctx context.Context) ApiGetDiscoverTvUpcomingRequest {
	return ApiGetDiscoverTvUpcomingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDiscoverTv2XXResponse
func (a *SearchAPIService) GetDiscoverTvUpcomingExecute(r ApiGetDiscoverTvUpcomingRequest) (*GetDiscoverTv2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDiscoverTv2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverTvUpcoming")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/tv/upcoming"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetDiscoverWatchlistRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	page *float32
}

func (r ApiGetDiscoverWatchlistRequest) Page(page float32) ApiGetDiscoverWatchlistRequest {
	r.page = &page
	return r
}

func (r ApiGetDiscoverWatchlistRequest) Execute() (*GetUserWatchlist2XXResponse, *http.Response, error) {
	return r.ApiService.GetDiscoverWatchlistExecute(r)
}

/*
GetDiscoverWatchlist Get the Plex watchlist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDiscoverWatchlistRequest
*/
func (a *SearchAPIService) GetDiscoverWatchlist(ctx context.Context) ApiGetDiscoverWatchlistRequest {
	return ApiGetDiscoverWatchlistRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetUserWatchlist2XXResponse
func (a *SearchAPIService) GetDiscoverWatchlistExecute(r ApiGetDiscoverWatchlistRequest) (*GetUserWatchlist2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUserWatchlist2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetDiscoverWatchlist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/watchlist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetSearchRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	query *string
	page *float32
	language *string
}

func (r ApiGetSearchRequest) Query(query string) ApiGetSearchRequest {
	r.query = &query
	return r
}

func (r ApiGetSearchRequest) Page(page float32) ApiGetSearchRequest {
	r.page = &page
	return r
}

func (r ApiGetSearchRequest) Language(language string) ApiGetSearchRequest {
	r.language = &language
	return r
}

func (r ApiGetSearchRequest) Execute() (*GetSearch2XXResponse, *http.Response, error) {
	return r.ApiService.GetSearchExecute(r)
}

/*
GetSearch Search for movies, TV shows, or people

Returns a list of movies, TV shows, or people a JSON object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSearchRequest
*/
func (a *SearchAPIService) GetSearch(ctx context.Context) ApiGetSearchRequest {
	return ApiGetSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSearch2XXResponse
func (a *SearchAPIService) GetSearchExecute(r ApiGetSearchRequest) (*GetSearch2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSearch2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetSearchCompanyRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	query *string
	page *float32
}

func (r ApiGetSearchCompanyRequest) Query(query string) ApiGetSearchCompanyRequest {
	r.query = &query
	return r
}

func (r ApiGetSearchCompanyRequest) Page(page float32) ApiGetSearchCompanyRequest {
	r.page = &page
	return r
}

func (r ApiGetSearchCompanyRequest) Execute() (*GetSearchCompany2XXResponse, *http.Response, error) {
	return r.ApiService.GetSearchCompanyExecute(r)
}

/*
GetSearchCompany Search for companies

Returns a list of TMDB companies matching the search query. (Will not return origin country)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSearchCompanyRequest
*/
func (a *SearchAPIService) GetSearchCompany(ctx context.Context) ApiGetSearchCompanyRequest {
	return ApiGetSearchCompanyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSearchCompany2XXResponse
func (a *SearchAPIService) GetSearchCompanyExecute(r ApiGetSearchCompanyRequest) (*GetSearchCompany2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSearchCompany2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetSearchCompany")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search/company"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiGetSearchKeywordRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	query *string
	page *float32
}

func (r ApiGetSearchKeywordRequest) Query(query string) ApiGetSearchKeywordRequest {
	r.query = &query
	return r
}

func (r ApiGetSearchKeywordRequest) Page(page float32) ApiGetSearchKeywordRequest {
	r.page = &page
	return r
}

func (r ApiGetSearchKeywordRequest) Execute() (*GetSearchKeyword2XXResponse, *http.Response, error) {
	return r.ApiService.GetSearchKeywordExecute(r)
}

/*
GetSearchKeyword Search for keywords

Returns a list of TMDB keywords matching the search query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSearchKeywordRequest
*/
func (a *SearchAPIService) GetSearchKeyword(ctx context.Context) ApiGetSearchKeywordRequest {
	return ApiGetSearchKeywordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSearchKeyword2XXResponse
func (a *SearchAPIService) GetSearchKeywordExecute(r ApiGetSearchKeywordRequest) (*GetSearchKeyword2XXResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSearchKeyword2XXResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.GetSearchKeyword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search/keyword"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiListDiscoverGenresliderMovieRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	language *string
}

func (r ApiListDiscoverGenresliderMovieRequest) Language(language string) ApiListDiscoverGenresliderMovieRequest {
	r.language = &language
	return r
}

func (r ApiListDiscoverGenresliderMovieRequest) Execute() ([]*ListDiscoverGenresliderMovie2XXResponseInner, *http.Response, error) {
	return r.ApiService.ListDiscoverGenresliderMovieExecute(r)
}

/*
ListDiscoverGenresliderMovie Get genre slider data for movies

Returns a list of genres with backdrops attached

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDiscoverGenresliderMovieRequest
*/
func (a *SearchAPIService) ListDiscoverGenresliderMovie(ctx context.Context) ApiListDiscoverGenresliderMovieRequest {
	return ApiListDiscoverGenresliderMovieRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListDiscoverGenresliderMovie2XXResponseInner
func (a *SearchAPIService) ListDiscoverGenresliderMovieExecute(r ApiListDiscoverGenresliderMovieRequest) ([]*ListDiscoverGenresliderMovie2XXResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []*ListDiscoverGenresliderMovie2XXResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.ListDiscoverGenresliderMovie")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/genreslider/movie"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
type ApiListDiscoverGenresliderTvRequest struct {
	ctx context.Context
	ApiService *SearchAPIService
	language *string
}

func (r ApiListDiscoverGenresliderTvRequest) Language(language string) ApiListDiscoverGenresliderTvRequest {
	r.language = &language
	return r
}

func (r ApiListDiscoverGenresliderTvRequest) Execute() ([]*ListDiscoverGenresliderMovie2XXResponseInner, *http.Response, error) {
	return r.ApiService.ListDiscoverGenresliderTvExecute(r)
}

/*
ListDiscoverGenresliderTv Get genre slider data for TV series

Returns a list of genres with backdrops attached

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDiscoverGenresliderTvRequest
*/
func (a *SearchAPIService) ListDiscoverGenresliderTv(ctx context.Context) ApiListDiscoverGenresliderTvRequest {
	return ApiListDiscoverGenresliderTvRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ListDiscoverGenresliderMovie2XXResponseInner
func (a *SearchAPIService) ListDiscoverGenresliderTvExecute(r ApiListDiscoverGenresliderTvRequest) ([]*ListDiscoverGenresliderMovie2XXResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []*ListDiscoverGenresliderMovie2XXResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SearchAPIService.ListDiscoverGenresliderTv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/discover/genreslider/tv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.language != nil {
		localVarQueryParams.Add("language", parameterToString(*r.language, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
